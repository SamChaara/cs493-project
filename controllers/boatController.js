const { Datastore } = require("@google-cloud/datastore");
const common = require("./resources/projectCommon");

const datastore = new Datastore();

/*
Create a Boat
Allows you to create a new boat.
POST /boats
*/
exports.create_boat = async function (req, res) {
  if (!(req.body.name && req.body.type && req.body.length)) {
    //name, type, and length were not all supplied -> send 400
    res.status(400).json(common.BOAT400);
  } else {
    var boatKey = datastore.key(common.BOAT);

    //Boat to be stored in DataStore
    const newBoat = {
      name: req.body.name,
      type: req.body.type,
      length: req.body.length,
      owner: req.user.sub,
    };

    console.log(">>NEW BOAT: ", JSON.stringify(newBoat));

    const newEntity = {
      key: boatKey,
      data: newBoat,
    };

    await datastore.save(newEntity);

    res.status(201).json({
      id: newEntity.key.id,
      name: newEntity.data.name,
      type: newEntity.data.type,
      length: newEntity.data.length,
      owner: newEntity.data.owner,
      self: req.protocol + "://" + req.get("host") + req.baseUrl + "/" + newEntity.key.id,
    });
  }
};

/*
List all Boats
List all the boats.
GET /boats
*/
exports.list_boats = function (req, res) {
  var query = datastore.createQuery(common.BOAT).filter("owner", "=", req.user.sub).limit(common.PAGE_SIZE);

  //See if an offset was provided
  if (req.query.offset) {
    //Now start the query at the provided offset (cursor)
    query = query.start(req.query.offset);
  }

  datastore.runQuery(query, (err, entities, info) => {
    //Check to see if there are more results and a "next" link is needed
    if (info.moreResults !== Datastore.NO_MORE_RESULTS) {
      var nextLink = common.getNextLink(req, info.endCursor);
    }

    //Add the id property to each boat
    entities = entities.map(common.fromDatastore);

    //Build a self link locally and assign to each boat
    entities.forEach((entity) => {
      entity = common.addSelfLink(entity, req);

      //Add a self link to each load of each boat listed
      if (entity.loads) {
        entity.loads.forEach((load) => (load = common.addSelfLink(load, req, common.BASEURL_LOADS)));
      }
    });

    //Only include the "next" link if the nextLink was defined above
    var pageResult = nextLink ? { boats: entities, next: nextLink } : { boats: entities };

    res.status(200).json(pageResult);
  });
};

/*
Get a Boat
Allows you to get an existing boat
GET /boats/:boat_id
*/
exports.get_boat = function (req, res) {
  var boatId = parseInt(req.params.boat_id);
  var boatKey = datastore.key([common.BOAT, boatId]);

  //Query datastore and filter by the key generated by the boat_id provided
  const query = datastore.createQuery(common.BOAT).filter("__key__", "=", boatKey).limit(1);

  datastore.runQuery(query, (err, entities, info) => {
    //Check for empty result set
    if (entities.length == 0) {
      res.status(404).json(common.BOAT404);
    } else {
      //[0][0] to access the query result's object only, rather than list of query results
      var targetBoat = entities[0];

      if (targetBoat.owner !== req.user.sub) {
        //User provided valid auth, but they are not the owner
        //of the requested boat (forbidden)
        res.status(403).json(common.BOAT403);
      } else {
        targetBoat = common.fromDatastore(targetBoat);
        targetBoat = common.addSelfLink(targetBoat, req);

        if (targetBoat.loads) {
          targetBoat.loads.forEach((entity) => (entity = common.addSelfLink(entity, req, common.BASEURL_LOADS)));
        }

        res.status(200).json(targetBoat);
      }
    }
  });
};

/*
Edit a Boat
Allows you to edit a boat.
PATCH /boats/:boat_id
*/
exports.edit_boat = function (req, res) {
  if (!(req.body.name && req.body.type && req.body.length)) {
    //name, type, and length were not all supplied -> send 400
    res.status(400).json(common.BOAT400);
  } else {
    var boatId = parseInt(req.params.boat_id);
    var boatKey = datastore.key([common.BOAT, boatId]);

    const query = datastore.createQuery(common.BOAT).filter("__key__", "=", boatKey).limit(1);

    datastore.runQuery(query, (err, entities, info) => {
      //Check for empty result set
      if (entities.length == 0) {
        res.status(404).json(common.BOAT404);
      } else {
        //Check that the authed user is the owner
        var targetBoat = entities[0];

        if (targetBoat.owner !== req.user.sub) {
          //User provided valid auth, but they are not the owner
          //of the requested boat (forbidden)
          res.status(403).json(common.BOAT403);
        } else {
          //Build the updated boat object
          const updatedBoat = {
            name: req.body.name,
            type: req.body.type,
            length: req.body.length,
            owner: targetBoat.owner,
          };

          //Define the updated entity based on requested boat_id
          const updatedEntity = {
            key: boatKey,
            data: updatedBoat,
          };

          datastore.update(updatedEntity, (err, apiResp) => {
            if (err) {
              //No update took place -> send 404 with message
              res.status(404).json(common.BOAT404);
            } else {
              //Update was successful -> Send 200 with object in body
              res.status(200).json({
                id: updatedEntity.key.id,
                name: updatedEntity.data.name,
                type: updatedEntity.data.type,
                length: updatedEntity.data.length,
                owner: updatedEntity.data.owner,
                self: req.protocol + "://" + req.get("host") + req.baseUrl + "/" + updatedEntity.key.id,
              });
            }
          });
        }
      }
    });
  }
};

/*
Delete a Boat
Allows you to delete a boat.
DELETE /boats/:boat_id
*/
exports.delete_boat = function (req, res) {
  var boatId = parseInt(req.params.boat_id);
  var boatKey = datastore.key([common.BOAT, boatId]);

  //Query datastore and filter by the key generated by the boat_id provided
  const query = datastore.createQuery(common.BOAT).filter("__key__", "=", boatKey).limit(1);

  datastore.runQuery(query, (err, entities, info) => {
    //Check for empty result set
    if (entities.length == 0) {
      res.status(404).json(common.BOAT404);
    } else {
      //Check that the authed user is the owner
      var targetBoat = entities[0];

      if (targetBoat.owner !== req.user.sub) {
        //User provided valid auth, but they are not the owner
        //of the requested boat (forbidden)
        res.status(403).json(common.BOAT403);
      } else {
        datastore.delete(boatKey, (err, apiResp) => {
          if (apiResp.indexUpdates == 0) {
            //No delete took place -> send 403
            res.status(403).end();
          } else {
            //Successfully deleted -> send 204 with no body
            res.status(204).end(); //Use .end() to send response without content
          }
        });
      }
    }
  });
};

/*
Add a Load to a Boat
Add existing load to specified boat.
PUT /boats/:boat_id/loads/:load_id
*/
exports.add_load = async function (req, res) {
  var boatId = parseInt(req.params.boat_id);
  var boatKey = datastore.key([common.BOAT, boatId]);

  var loadId = parseInt(req.params.load_id);
  var loadKey = datastore.key([common.LOAD, loadId]);

  //First check that the boat_id exists
  const boatQuery = datastore.createQuery(common.BOAT).filter("__key__", "=", boatKey).limit(1);
  datastore.runQuery(boatQuery, (err, entities, info) => {
    if (entities.length == 0) {
      res.status(404).json(common.BOAT404);
    } else {
      //Boat exists
      var targetBoat = entities[0];
      targetBoat = common.fromDatastore(targetBoat);

      if (targetBoat.owner !== req.user.sub) {
        //User provided valid auth, but they are not the owner
        //of the requested boat (forbidden)
        res.status(403).json(common.BOAT403);
      } else {
        //Now check that the load_id exists
        const loadQuery = datastore.createQuery(common.LOAD).filter("__key__", "=", loadKey).limit(1);
        datastore.runQuery(loadQuery, (err, entities, info) => {
          if (entities.length == 0) {
            res.status(404).json(common.LOAD404);
          } else {
            //Load also exists
            var targetLoad = entities[0];
            targetLoad = common.fromDatastore(targetLoad);
            targetLoad = common.addSelfLink(targetLoad, req, common.BASEURL_LOADS);

            //Check that the load isn't already on a boat
            if (targetLoad.carrier) {
              //Already loaded on another boat -> Send 403
              res.status(403).json(common.LOAD403);
            }

            /*Now safe to create association between boat and load*/
            var minimalTargetBoat = { id: targetBoat.id };
            var minimalTargetLoad = { id: targetLoad.id };

            //Associate load with boat
            //Check if the boat already has a "loads" list and append to it if so
            //Create a "loads" list if not already present
            targetBoat.loads = targetBoat.loads ? targetBoat.loads.concat([minimalTargetLoad]) : [minimalTargetLoad];

            //Associate boat with load
            targetLoad.carrier = minimalTargetBoat;

            //Save the updated boat (with added load) to datastore
            var updatedBoat = {
              name: targetBoat.name,
              type: targetBoat.type,
              length: targetBoat.length,
              owner: targetBoat.owner,
              loads: targetBoat.loads,
            };

            var updatedBoatEntity = {
              key: boatKey,
              data: updatedBoat,
            };

            datastore.update(updatedBoatEntity, (err, apiResp) => {
              if (err) {
                res.status(500).json(common.BOAT500);
              } else {
                //Boat updated successfully
              }
            });

            //Save the updated load (with added carrier) to datastore
            var updatedLoad = {
              weight: targetLoad.weight,
              content: targetLoad.content,
              delivery_date: targetLoad.delivery_date,
              carrier: targetLoad.carrier,
            };

            var updatedLoadEntity = {
              key: loadKey,
              data: updatedLoad,
            };

            datastore.update(updatedLoadEntity, (err, apiResp) => {
              if (err) {
                res.status(500).json(common.LOAD500);
              } else {
                //Load updated successfully
              }
            });

            //Add self link to the boat after saving, but before sending response
            targetBoat = common.addSelfLink(targetBoat, req);

            //Add self link to each load on the boat
            targetBoat.loads.forEach((entity) => (entity = common.addSelfLink(entity, req, common.BASEURL_LOADS)));
            res.status(200).json(targetBoat);
          }
        });
      }
    }
  });
};

/*
Remove a Load from a Boat
Remove specified load from boat. Does not delete load.
DELETE /boats/:boat_id/loads/:load_id
*/
exports.remove_load = async function (req, res) {
  var boatId = parseInt(req.params.boat_id);
  var boatKey = datastore.key([common.BOAT, boatId]);

  var loadId = parseInt(req.params.load_id);
  var loadKey = datastore.key([common.LOAD, loadId]);

  //First check that the boat_id exists
  const boatQuery = datastore.createQuery(common.BOAT).filter("__key__", "=", boatKey).limit(1);
  datastore.runQuery(boatQuery, (err, entities, info) => {
    if (entities.length == 0) {
      res.status(404).json(common.BOAT404);
    } else {
      //Boat exists
      var targetBoat = entities[0];
      targetBoat = common.fromDatastore(targetBoat);

      if (targetBoat.owner !== req.user.sub) {
        //User provided valid auth, but they are not the owner
        //of the requested boat (forbidden)
        res.status(403).json(common.BOAT403);
      } else {
        //Now check that the load_id exists
        const loadQuery = datastore.createQuery(common.LOAD).filter("__key__", "=", loadKey).limit(1);
        datastore.runQuery(loadQuery, (err, entities, info) => {
          if (entities.length == 0) {
            res.status(404).json(common.LOAD404);
          } else {
            //Load also exists
            var targetLoad = entities[0];

            //Remove the load from the target boat's load array
            if (targetBoat.loads) {
              //Iterate through target boat's loads, looking for load to remove
              for (let i = targetBoat.loads.length - 1; i >= 0; i--) {
                if (targetBoat.loads[i].id == req.params.load_id) {
                  //Load is in the boat's loads array
                  //Use array.splice to remove from array: https://stackoverflow.com/a/58380732
                  targetBoat.loads.splice(i, 1);
                }
              }

              //Remove the loads array if empty
              if (targetBoat.loads.length == 0) {
                delete targetBoat.loads;
              }
            }

            //Now update datastore with the updated loads array
            var updatedBoatEntity = {
              key: boatKey,
              data: targetBoat,
            };

            datastore.update(updatedBoatEntity, (err, apiResp) => {
              if (err) {
                res.status(500).json(common.BOAT500);
              } else {
                //Boat updated successfully
              }
            });

            if (targetLoad.carrier && targetLoad.carrier.id == req.params.boat_id) {
              delete targetLoad.carrier;
            }

            var updatedLoadEntity = {
              key: loadKey,
              data: targetLoad,
            };

            datastore.update(updatedLoadEntity, (err, apiResp) => {
              if (err) {
                res.status(500).json(common.LOAD500);
              } else {
                //Load updated successfully
              }
            });

            //Add self link to the boat after saving, but before sending response
            targetBoat = common.addSelfLink(targetBoat, req);

            //Add self link to each load on the boat
            if (targetBoat.loads) {
              targetBoat.loads.forEach((entity) => (entity = common.addSelfLink(entity, req, common.BASEURL_LOADS)));
            }
            res.status(200).json(targetBoat);
          }
        });
      }
    }
  });
};
